# Hard Problems - Notes

## General Strategies for Hard Problems

- **Advanced Dynamic Programming**: Multi-dimensional DP, DP with optimization
- **Complex Graph Algorithms**: Shortest path with constraints, network flow
- **Advanced Tree Problems**: Segment trees, binary indexed trees
- **Mathematical Insights**: Number theory, combinatorics, game theory
- **Optimization Techniques**: Binary search on answer, greedy with proof

## Key Takeaways

- Hard problems often require deep understanding of algorithms and data structures
- Multiple techniques may need to be combined
- Mathematical insights can simplify seemingly complex problems
- Time and space optimization is crucial
- Edge cases and corner cases are critical

## Common Patterns

1. **Advanced Dynamic Programming**:
   - DP with bitmask
   - Interval DP
   - Tree DP
   - Digit DP
   - DP with data structure optimization

2. **Graph Algorithms**:
   - Dijkstra's algorithm
   - Floyd-Warshall
   - Minimum spanning tree
   - Network flow
   - Strongly connected components

3. **String Algorithms**:
   - KMP (pattern matching)
   - Trie with optimization
   - Rolling hash
   - Manacher's algorithm (palindromes)

4. **Advanced Data Structures**:
   - Segment tree
   - Binary indexed tree (Fenwick tree)
   - Union-find with path compression
   - Monotonic stack/queue

5. **Optimization Techniques**:
   - Binary search on answer
   - Sliding window with deque
   - Two pointers with multiple conditions
   - Greedy with mathematical proof

## Tips

- Break down the problem into smaller subproblems
- Look for similar problems you've solved before
- Consider multiple approaches and their trade-offs
- Prove correctness of greedy approaches
- Use visualization to understand the problem
- Practice is key - hard problems become easier with exposure
- Don't hesitate to look at hints or solutions after genuine effort
- Learn from editorial solutions and optimize further
